[{"content":"Arrow function이와 function 키워드의 가장 큰 차이점은 this 의 차이이다.\n1. 왜 이벤트 리스너에서 일반적으로 arrow function을 사용하면 안될까? \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;function\u0026#34;\u0026gt;function\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;arrow\u0026#34;\u0026gt;arrow function\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const functionButton = document.querySelector(\u0026#39;#function\u0026#39;) const arrowButton = document.querySelector(\u0026#39;#arrow\u0026#39;) functionButton.addEventListener(\u0026#39;click\u0026#39;, function (event) { console.log(\u0026#39;=====function=====\u0026#39;) console.log(this) }) arrowButton.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { console.log(\u0026#39;=====arrow fuction=====\u0026#39;) console.log(this) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 각각의 버튼을 눌러서 확인을 해보자.\n=====function===== \u0026lt;button id=\u0026quot;function\u0026quot;\u0026gt;function\u0026lt;/button\u0026gt; =====arrow fuction===== Window 2. this 자바스크립트의 this는 일반적인 프로그래밍 언어에서의 this와 조금 다르게 동작한다.\njava this와 python self의 인스턴스의 호출한 대상의 현재 객체를 뜻하는 것(참조)이었다.\n자바스크립트의 function 키워드 함수에서는 함수가 어떻게 호출 되었는지에 따라 다르게 동작한다. (동적으로 결정)\n브라우저 콘솔에 this를 입력 해보자.\n 브라우저 콘솔과 this \n2-1. window : 함수 호출, 함수 내 함수 window는 브라우저에서의 최상위 객체를 의미한다. (전역 객체)\n기본적인 함수 선언을 하고 호출한다면, 이 경우에는 전역에서 호출 하였으므로 전역 객체가 바인딩된다.\nconst greeting = function() { console.log(this) } greeting() // window 함수 내 함수는 추후에 다루겠다.\n2-2. 객체 : 메소드 호출 메소드로 선언하고 호출한다면, 오브젝트의 메소드이므로 오브젝트가 바인딩된다.\nconst you = { name: \u0026#39;neo\u0026#39;, greeting } you.greeting() // {name: \u0026#39;neo\u0026#39;, greeting: f} : this는 해당 오브젝트(객체) 2-3. Arrow Function arrow function에서의 this는 어떻게 동작할까?\narrow function에서는 호출과 위치와 상관없이 상위 스코프 this를 가리킨다. (Lexical this)\n따라서, 메소드 선언을 arrow 함수로 하게 된다면, 해당 오브젝트의 상위 스코프인 전역 객체인 window가 바인딩된다.\nconst arrowGreeting = () =\u0026gt; { console.log(this) } const me = { name: \u0026#39;me\u0026#39;, arrowGreeting } arrowGreeting() // window me.arrowGreeting() // window 메소드 선언은 function 키워드를 활용하자!\n그러면 ES6에서 언제 arrow function을 활용하면 편할까? const num = { numbers: [1], print: function () { console.log(this) // {numbers: Array(1), print: ƒ}  console.log(this.numbers) // [1]  this.numbers.forEach(function (num) { console.log(num) // 1  console.log(this) // window  }) } } num.print()  내부 함수에서는 어디든 상관 없이 항상 전역객체를 바인딩한다. 뒤에 이야기 한다고 했던 함수 내의 함수 상황의 예시가 위와 같다. 이때 arrow function을 쓰면 좋다! print 메소드의 내에 있는 콜백함수(forEach)에서의 상위 스코프는 num2 오브젝트이다. 따라서, this가 아래와 같이 해당 오브젝트가 바인딩 된다.  const num2 = { numbers: [1], print: function () { console.log(this) // {numbers: Array(1), print: ƒ}  console.log(this.numbers) // [1]  this.numbers.forEach(num =\u0026gt; { console.log(num) // 1  console.log(this) // {numbers: Array(1), print: ƒ}  }) } } num2.print() 다시 이벤트 리스너로 돌아와서, addEventListener 에서의 콜백 함수는 특별하게 function키워드의 경우에는 이벤트 리스너를 호출한 대상을 (event.target) 뜻한다. 따라서, 호출한 대상을 원한다면 this 를 활용할 수 있다.\n다만, arrow function의 경우 상위 스코프를 지칭하기 때문에 window 객체가 출력된 것이다.\n3. 정리 Arrow Function을 쓰면 안되는 대표적인 경우는 다음과 같다.\n  object의 메소드 정의\n this가 전역 객체(window)를 나타낸다.    생성자 함수\n  생성자 함수는 object를 생성하는 또다른 방법이다.\nconst MyInfo = { name: \u0026#39;tak\u0026#39;, phoneNumber : \u0026#39;010-1234-5678\u0026#39;, greeting() { console.log(this.name + \u0026#39;hi\u0026#39;) } } const Person = function (name) { this.name = name this.greeting = function() { console.log(this.name + \u0026#39;hi\u0026#39;) } } const justin = new Person(\u0026#39;justin\u0026#39;)   Arrow function을 사용하면 에러가 발생한다.\nconst Animal = name =\u0026gt; { this.name = name } const dog = new Animal(\u0026#39;dog\u0026#39;) // Uncaught TypeError: Animal is not a constructor     addEventListener 함수의 콜백 함수\n this가 전역 객체(window)를 나타낸다.    ","date":"2021-01-20T16:57:00+09:00","image":"https://notes.hphk.io/p/arrow-function-vs-regular-function/images/carbon_hueccd1a0ba10ac6631bac2c5f78c0c98f_103920_120x120_fill_box_smart1_2.png","permalink":"https://notes.hphk.io/p/arrow-function-vs-regular-function/","title":"Arrow Function vs Regular Function"}]