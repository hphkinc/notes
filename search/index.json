[{"content":" Git Bash가 설치되어 있어야 합니다.\n 1. Windows Terminal 설치 Microsoft Store에서 Windows Terminal을 설치합니다.\n Microsoft Store - Windows Terminal \n2. Windows Terminal 실행 처음 실행하면 기본으로 PowerShell, CMD, Azure Cloud Shell을 사용할 수 있도록 되어 있습니다.\n Windows Terminal shell list \n설정을 통해 추가적인 Shell(Bash)을 사용할 수 있도록 해봅시다.\n3. Windows Terminal 설정 설정 메뉴를 클릭하거나 ctrl + , 단축키를 사용하여, 설정 파일을 열 수 있습니다.\n settings.json \n메모장으로 열리기 때문에 편집이 불편할 수 있습니다. 다른 에디터를 사용하실 분들은 다른 이름으로 저장 메뉴 또는 ctrl + shift + s 단축키를 사용하여 \u0026lsquo;다른 이름으로 저장\u0026rsquo; 창을 열고, 해당 위치를 원하는 에디터로 열어 설정 파일을 편집합니다. 여기서는 VS Code를 사용하겠습니다. Code로 열기 컨텍스트 메뉴를 통해 VS Code에서 설정 파일이 존재하는 폴더를 열어 줍니다.\n Open with VS Code \nprofiles 항목에 Git Bash 프로필을 추가합니다.\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { }, \u0026#34;list\u0026#34;: [ { \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe\u0026#34;, \u0026#34;hidden\u0026#34;: false }, { \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;명령 프롬프트\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;hidden\u0026#34;: false }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{124fc1da-dadc-4276-9c4e-f0524ba57a49}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Git Bash\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;\\\u0026#34;%PROGRAMFILES%\\\\git\\\\usr\\\\bin\\\\bash.exe\\\u0026#34; -i -l\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;%PROGRAMFILES%\\\\git\\\\mingw64\\\\share\\\\git\\\\git-for-windows.ico\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;%USERPROFILE%\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;filledBox\u0026#34;, \u0026#34;hidden\u0026#34;: false } ] }, } 이 때 프로필의 guid는 해당 프로필의 고유 아이디이며, 저 포멧을 사용하고 다른 값과 중복되지만 않으면 어떠한 값도 사용 가능합니다. 위의 guid를 그대로 사용해도 되지만, 새롭게 생성하고 싶으신 분들은 PowerShell에서 아래의 명령어를 입력하여 새롭게 생성할 수 있습니다.\n[guid]::NewGuid()  Generate new guid \n다양한 프로필 설정법은 https://aka.ms/terminal-profile-settings 에서 확인 가능합니다.\n저장을 하고 나면 아래와 같이 Git Bash가 추가된 것을 확인할 수 있습니다.\n Git Bash on shell list   Git Bash with Windows Terminal \n4. 기본 프로필 설정  새 탭을 열었을 때 기본으로 나오는 프로필을 변경하려면, 기본으로 설정하고자 하는 프로필의 guid를 defaultProfile 키의 값으로 지정하면 됩니다.  { \u0026#34;defaultProfile\u0026#34;: \u0026#34;[guid]\u0026#34;, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{124fc1da-dadc-4276-9c4e-f0524ba57a49}\u0026#34;, } ","date":"2021-01-21T15:10:00+09:00","image":"https://notes.hphk.io/p/git-bash-with-windows-terminal/images/windows-terminal_hufc8951bee89e530b0cd79fbaaa1fd3e9_153553_120x120_fill_q75_box_smart1.jpeg","permalink":"https://notes.hphk.io/p/git-bash-with-windows-terminal/","title":"Git Bash with Windows Terminal"},{"content":"Arrow function이와 function 키워드의 가장 큰 차이점은 this 의 차이이다.\n1. 왜 이벤트 리스너에서 일반적으로 arrow function을 사용하면 안될까? \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;function\u0026#34;\u0026gt;function\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;arrow\u0026#34;\u0026gt;arrow function\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const functionButton = document.querySelector(\u0026#39;#function\u0026#39;) const arrowButton = document.querySelector(\u0026#39;#arrow\u0026#39;) functionButton.addEventListener(\u0026#39;click\u0026#39;, function (event) { console.log(\u0026#39;=====function=====\u0026#39;) console.log(this) }) arrowButton.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { console.log(\u0026#39;=====arrow fuction=====\u0026#39;) console.log(this) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 각각의 버튼을 눌러서 확인을 해보자.\n=====function===== \u0026lt;button id=\u0026quot;function\u0026quot;\u0026gt;function\u0026lt;/button\u0026gt; =====arrow fuction===== Window 2. this 자바스크립트의 this는 일반적인 프로그래밍 언어에서의 this와 조금 다르게 동작한다.\njava this와 python self의 인스턴스의 호출한 대상의 현재 객체를 뜻하는 것(참조)이었다.\n자바스크립트의 function 키워드 함수에서는 함수가 어떻게 호출 되었는지에 따라 다르게 동작한다. (동적으로 결정)\n브라우저 콘솔에 this를 입력 해보자.\n 브라우저 콘솔과 this \n2-1. window : 함수 호출, 함수 내 함수 window는 브라우저에서의 최상위 객체를 의미한다. (전역 객체)\n기본적인 함수 선언을 하고 호출한다면, 이 경우에는 전역에서 호출 하였으므로 전역 객체가 바인딩된다.\nconst greeting = function() { console.log(this) } greeting() // window 함수 내 함수는 추후에 다루겠다.\n2-2. 객체 : 메소드 호출 메소드로 선언하고 호출한다면, 오브젝트의 메소드이므로 오브젝트가 바인딩된다.\nconst you = { name: \u0026#39;neo\u0026#39;, greeting } you.greeting() // {name: \u0026#39;neo\u0026#39;, greeting: f} : this는 해당 오브젝트(객체) 2-3. Arrow Function arrow function에서의 this는 어떻게 동작할까?\narrow function에서는 호출과 위치와 상관없이 상위 스코프 this를 가리킨다. (Lexical this)\n따라서, 메소드 선언을 arrow 함수로 하게 된다면, 해당 오브젝트의 상위 스코프인 전역 객체인 window가 바인딩된다.\nconst arrowGreeting = () =\u0026gt; { console.log(this) } const me = { name: \u0026#39;me\u0026#39;, arrowGreeting } arrowGreeting() // window me.arrowGreeting() // window 메소드 선언은 function 키워드를 활용하자!\n그러면 ES6에서 언제 arrow function을 활용하면 편할까? const num = { numbers: [1], print: function () { console.log(this) // {numbers: Array(1), print: ƒ}  console.log(this.numbers) // [1]  this.numbers.forEach(function (num) { console.log(num) // 1  console.log(this) // window  }) } } num.print()  내부 함수에서는 어디든 상관 없이 항상 전역객체를 바인딩한다. 뒤에 이야기 한다고 했던 함수 내의 함수 상황의 예시가 위와 같다. 이때 arrow function을 쓰면 좋다! print 메소드의 내에 있는 콜백함수(forEach)에서의 상위 스코프는 num2 오브젝트이다. 따라서, this가 아래와 같이 해당 오브젝트가 바인딩 된다.  const num2 = { numbers: [1], print: function () { console.log(this) // {numbers: Array(1), print: ƒ}  console.log(this.numbers) // [1]  this.numbers.forEach(num =\u0026gt; { console.log(num) // 1  console.log(this) // {numbers: Array(1), print: ƒ}  }) } } num2.print() 다시 이벤트 리스너로 돌아와서, addEventListener 에서의 콜백 함수는 특별하게 function키워드의 경우에는 이벤트 리스너를 호출한 대상을 (event.target) 뜻한다. 따라서, 호출한 대상을 원한다면 this 를 활용할 수 있다.\n다만, arrow function의 경우 상위 스코프를 지칭하기 때문에 window 객체가 출력된 것이다.\n3. 정리 Arrow Function을 쓰면 안되는 대표적인 경우는 다음과 같다.\n  object의 메소드 정의\n this가 전역 객체(window)를 나타낸다.    생성자 함수\n  생성자 함수는 object를 생성하는 또다른 방법이다.\nconst MyInfo = { name: \u0026#39;tak\u0026#39;, phoneNumber : \u0026#39;010-1234-5678\u0026#39;, greeting() { console.log(this.name + \u0026#39;hi\u0026#39;) } } const Person = function (name) { this.name = name this.greeting = function() { console.log(this.name + \u0026#39;hi\u0026#39;) } } const justin = new Person(\u0026#39;justin\u0026#39;)   Arrow function을 사용하면 에러가 발생한다.\nconst Animal = name =\u0026gt; { this.name = name } const dog = new Animal(\u0026#39;dog\u0026#39;) // Uncaught TypeError: Animal is not a constructor     addEventListener 함수의 콜백 함수\n this가 전역 객체(window)를 나타낸다.    ","date":"2021-01-20T16:57:00+09:00","image":"https://notes.hphk.io/p/arrow-function-vs-regular-function/images/carbon_hueccd1a0ba10ac6631bac2c5f78c0c98f_103920_120x120_fill_box_smart1_2.png","permalink":"https://notes.hphk.io/p/arrow-function-vs-regular-function/","title":"Arrow Function vs Regular Function"}]